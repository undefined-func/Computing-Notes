# -*- coding: utf-8 -*-
"""Sort Algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UGY-xWLFkTPTJ0a9snvV0Ysc7ahIM5BF

#Sort Algorithms

Implement sort algorithms.

*   Insertion sort
*   Bubble sort
*   Quicksort
*   Merge sort
"""

#Run this cell first to generate test data.
from random import randint
test = [randint(1, 50) for i in range(10)]
test

#Or copy and paste a list into this cell (and run).
test =

"""## Bubble Sort

Worst-case time complexity: $O(n^{2})$

### Notes
After the $n$th pass, the last $n$ elements are bubbled up in place.

### Algorithm

1.   Starting with the first element, compare the current element with the next element.
2.   If current element > next element, do a swap.
3.   Assign current element to next element.
4.   Repeat steps 1-3 for the first $n$ element for the $n$th pass.
5.   Sorting is complete when there is no swaps in a pass.
"""

def bubble_sort(arr):
    exchanges = True
    pass_no = len(arr) - 1
    while pass_no > 0 and exchanges:
        exchanges = False
        for i in range(pass_no):
            if arr[i] > arr[i+1]:
                temp = arr[i]
                arr[i] = arr[i+1]
                arr[i+1] = temp
                exchanges = True
        pass_no -= 1
    return arr

def recursive_bubble_sort(arr):
    if len(arr) == 1:
        return arr
    else:
        swap = False
        for i in range(len(arr)-1):
            if arr[i] > arr[i+1]:
                temp = arr[i]
                arr[i] = arr[i+1]
                arr[i+1] = temp
                swap = True
        if swap == False:
            return arr
        else:
            return recursive_bubble_sort(arr[:-1]) + [arr[-1]]

bubble_sort(test)

recursive_bubble_sort(test)

"""##Insertion sort

Worst-case time complexity: $O(n^{2})$

### Notes
A sorted portion of the array is maintained on the left-hand side. The first element is sorted.

### Algorithm

1.   Starting with the second element, compare with the elements in the sorted sub-array.
2.   Shift all the elements that are greater than the current element one position to the right.
3.   Insert the element.
4.   Repeat steps 1-3 for all elements.
"""

def insertion_sort(arr):
    for i in range(1, len(arr)):
        
        #element to be compared
        key = arr[i]
        position = i
        
        #Move elements of arr[0..position-1] that are greater than key to
        #one position ahead of their current position.
        while position > 0 and arr[position-1] > key:
            arr[position] = arr[position-1]
            position = position - 1
            
        arr[position] = key
    return arr

def recursive_insertion_sort(arr):
    if len(arr) == 1:
        return arr
    else:
        key = arr[0]
        position = 0
        
        while position > 0 and arr[postion-1] > key:
            arr[position] = arr[position-1]
            position -= 1
        
        arr[position] = key
        
        return arr[1:]

insertion_sort(test)

recursive_insertion_sort(test)

"""##Merge sort

Worst-case time complexity: $O(n\log{n})$

### Algorithm

1.   Split the array into 2 sub-arrays recursively until sub-arrays contain only one single element.
2.   Merge the sub-arrays into a single array.
> 1.    Compare the first $n$ elements of the sub-arrays.
  2.    The smaller of the two elements is appended to the new array
  3.    Repeat until both sub-arrays are empty.
"""

def merge_sort(arr, l, r):
    if l < r:
        m = (l+r) // 2
        
        merge_sort(arr, l, m) #Sort first and second halves
        merge_sort(arr, m+1, r)
        
        return merge(arr, l, m, r)
      
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    #create temp arrays
    L = [0] * n1
    R = [0] * n2
    
    #copy data into temp arrays L and R
    for i in range(0, n1):
        L[i] = arr[l+i]
        
    for j in range(0, n2):
        R[j] = arr[m+1+j]
        
    #merge the temp arrays back into arr[l..r]
    i = 0
    j = 0
    k = l 
    
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

    return arr

merge_sort(test, 0, 9)

"""##Quicksort

Worst-case time complexity: $O(n^2)$

### Notes
2 pointers (left pointer and right pointer) are maintained for insertion of pivot into the correct position. The pointers are moved towards each other. When left pointer element > pivot and right pointer element < pivot, the elements are swapped. When the pointers cross over, the final position of the pivot is given by the right pointer.

### Algorithm
1. Assign the pivot to be the first element.
2. Partition the array using the pivot.
3. Recursively sort the array by partitioning until the sub-array contains only one single element.
"""

def quicksort(arr, first, last):
    if first < last:
        splitpoint = partition(arr, first, last)
        quicksort(arr, first, splitpoint-1)
        quicksort(arr, splitpoint+1, last)

    return arr

def partition(arr, first, last):
    pivot = arr[first]

    leftmark = first + 1
    rightmark = last 

    done = False

    while not done:
        while leftmark <= rightmark and arr[leftmark] <= pivot:
            leftmark += 1

        while rightmark >= leftmark and arr[rightmark] >= pivot:
            rightmark -= 1

        if rightmark < leftmark:
            done = True
        else:
            temp = arr[leftmark]
            arr[leftmark] = arr[rightmark]
            arr[rightmark] = temp

    temp = arr[first]
    arr[first] = arr[rightmark]
    arr[rightmark] = temp

    return rightmark

quicksort(test, 0, len(test)-1)

"""# Search Algorithms

Implement search algorithms.

*   Linear Search
*   Binary Search
*   Hash Table Search

## Linear Search

Worst-case time complexity: $O(n)$
"""

def linear_search(item, arr):
    i = 0
    listsize = len(arr)

    while i < listsize:
        if nlist[i] == item:
            return i
        i += 1
    
    return -1 #not found

"""## Binary Search
Worst-case time complexity: $O(\log{n})$

### Notes
Array has to be sorted first.
"""

def binary_search(item, arr):
    first = 0
    last = len(arr) - 1
    found = False

    while first <= last and not found:
        middle = (first+last)//2
        if arr[middle] == item:
            found = True
        else:
            if item < arr[middle]:
                last = middle - 1
            else:
                first = middle + 1

    return found

def recursive_binary_search(item, arr, first, last):
    if first > last:
        return False
    else:
        middle = len(arr)//2
        if arr[middle] == item:
            return True
        else:
            if item < arr[middle]:
                return recursive_binary_search(item, arr, first, middle-1)
            else:
                recursive_binary_search(item, arr, middle+1, last)

"""## Hash Table Search

Worst-case time complexity: $O(1)$

### Notes
To create a hash: Use hash_total % array size
"""

class MyHashTable:
    def __init__(self, capacity):
        self.capacity = capacity
        self.slots = [None] * self.capacity

    def hash_function(self, key):
        #Weighted ordinal hash
        key = str(key)
        i = 0
        hash = 0
        while i < len(key):
            hash += key[i] * i
            i += 1
        hash = hash % self.capacity
        return hash 

    def insert(self, key, data):
        position = self.hash_function(key)
        orig = position
        while True:
            if self.slots[position] is None: #Empty slot at hash value
                self.slots[position] = (key, data)
                return 0  
            elif self.slots[position][0] == key: #key already exists
                self.slots[position] = (key, data) #Update
                return 1
            
            position = (position + 1) % self.capacity
            if position == orig:
                return -1 #Hash table is full

    def search(self, search_key):
        position = self.hash_function(search_key)
        if self.slots[position] is None:
            return -1 #Record not in hash table
        for i in range(self.capacity):
            probe = (position + i) % self.capacity
            if self.slots[probe][0] == search_key:
                return self.slots[probe][1] #Record found
        return -1 #Record not in hash table
